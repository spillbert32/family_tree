<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Родовое древо</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      overflow: hidden;
    }
    .node circle {
      stroke: #555;
      stroke-width: 2px;
    }
    .male {
      fill: #5dade2;
    }
    .female {
      fill: #f1948a;
    }
    .link {
      fill: none;
      stroke: #999;
      stroke-width: 2px;
    }
    text {
      font-size: 12px;
      user-select: none;
    }
    .surname {
      font-weight: bold;
    }
  </style>
</head>
<body>
  <svg width="1800" height="1000"></svg>

  <script>
    fetch("db.json")
      .then(res => res.json())
      .then(data => buildTree(data.people));

    function buildTree(people) {
      const personMap = new Map(people.map(p => [p.id, p]));

      const pairsMap = new Map();

      // Супружеские пары
      people.forEach(p => {
        if (p.spouses) {
          p.spouses.forEach(spouseId => {
            const key = [p.id, spouseId].sort().join('_');
            if (!pairsMap.has(key)) {
              pairsMap.set(key, { spouses: [p.id, spouseId], children: [] });
            }
          });
        } else {
          pairsMap.set(p.id, { spouses: [p.id], children: [] });
        }
      });

      // Дети
      people.forEach(p => {
        if (p.parents && p.parents.length > 0) {
          const key = [...p.parents].sort().join('_');
          if (!pairsMap.has(key)) {
            pairsMap.set(key, { spouses: [...p.parents], children: [p.id] });
          } else {
            pairsMap.get(key).children.push(p.id);
          }
        }
      });

      function hasParents(id) {
        const p = personMap.get(id);
        return p && p.parents && p.parents.length > 0;
      }

      // Найти корни
      const roots = [];
      pairsMap.forEach((pair, key) => {
        if (pair.spouses.some(id => !hasParents(id))) {
          roots.push({ key, ...pair });
        }
      });

      function buildNode(key) {
        const pair = pairsMap.get(key);
        if (!pair) return null;

        return {
          id: key,
          spouses: pair.spouses.map(id => personMap.get(id)),
          children: pair.children.map(childId => {
            const child = personMap.get(childId);
            const spouseIds = child.spouses || [];
            const pairKey = [...[child.id], ...spouseIds].sort().join('_');
            return buildNode(pairKey) || {
              id: child.id,
              spouses: [child],
              children: []
            };
          })
        };
      }

      const treeData = roots.map(r => buildNode(r.key));

      const svg = d3.select("svg");
      const g = svg.append("g").attr("transform", "translate(100,50)");

      svg.call(d3.zoom().on("zoom", ({transform}) => {
        g.attr("transform", transform);
      }));

      const dx = 300;
      const dy = 300;
      const spouseSpacing = 100;
      const circleRadius = 24;

      function hierarchy(d) {
        return d3.hierarchy(d, d => d.children);
      }

      treeData.forEach((rootData, index) => {
        const root = hierarchy(rootData);
        d3.tree().nodeSize([dx, dy])(root);

        g.selectAll(".link" + index)
          .data(root.links())
          .join("path")
          .attr("class", "link")
          .attr("d", d3.linkVertical()
            .x(d => d.x + index * 800)
            .y(d => d.y));

        const node = g.selectAll(".node" + index)
          .data(root.descendants())
          .join("g")
          .attr("class", "node")
          .attr("transform", d => `translate(${d.x + index * 800},${d.y})`);

        node.each(function(d) {
          const el = d3.select(this);
          const spouses = d.data.spouses;

          const displaySurname = person => {
            if (
              person.gender === "female" &&
              person.spouses &&
              person.spouses.length > 0 &&
              person.maidenSurname &&
              person.maidenSurname !== person.surname
            ) {
              return `${person.surname} (дев. ${person.maidenSurname})`;
            }
            return person.surname;
          };

          const addText = (x, y, lines) => {
            lines.forEach((line, i) => {
              el.append("text")
                .attr("x", x)
                .attr("y", y + i * 14)
                .attr("text-anchor", "middle")
                .text(line);
            });
          };

          if (spouses.length === 2) {
            const [sp1, sp2] = spouses;

            // Круги
            el.append("circle")
              .attr("r", circleRadius)
              .attr("cx", -spouseSpacing / 2)
              .attr("class", sp1.gender === "male" ? "male" : "female");

            el.append("circle")
              .attr("r", circleRadius)
              .attr("cx", spouseSpacing / 2)
              .attr("class", sp2.gender === "male" ? "male" : "female");

            // Фамилия
            el.append("text")
              .attr("y", -circleRadius - 14)
              .attr("text-anchor", "middle")
              .attr("class", "surname")
              .text(displaySurname(sp1));

            // Имена
            addText(-spouseSpacing / 2, circleRadius + 16, [`${sp1.name} ${sp1.patronymic || ""}`.trim()]);
            addText(spouseSpacing / 2, circleRadius + 16, [`${sp2.name} ${sp2.patronymic || ""}`.trim()]);

          } else {
            const sp = spouses[0];

            el.append("circle")
              .attr("r", circleRadius)
              .attr("class", sp.gender === "male" ? "male" : "female");

            el.append("text")
              .attr("y", -circleRadius - 14)
              .attr("text-anchor", "middle")
              .attr("class", "surname")
              .text(displaySurname(sp));

            addText(0, circleRadius + 16, [`${sp.name} ${sp.patronymic || ""}`.trim()]);
          }
        });
      });
    }
  </script>
</body>
</html>
