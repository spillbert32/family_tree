<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Объединённое родовое древо с сохранением камеры</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; overflow: hidden; }
  .link { fill: none; stroke: #999; stroke-width: 2px; }
  .link-dashed { stroke-dasharray: 4 2; stroke: #bbb; }
  .node circle { stroke: #555; stroke-width: 2px; cursor: pointer; }
  .male { fill: #5dade2; }
  .female { fill: #f1948a; }
  text { font-size: 12px; user-select: none; pointer-events: none; }
  .surname { font-weight: bold; }
  .maiden { font-style: italic; font-size: 11px; fill: #666; }
</style>
</head>
<body>
<svg width="1800" height="1000"></svg>
<script>
  fetch("db.json")
    .then(res => res.json())
    .then(data => {
      const rootData = buildUnifiedTree(data.people);
      render(rootData);
    })
    .catch(err => console.error("Ошибка загрузки db.json:", err));

  function buildUnifiedTree(people) {
    const map = new Map(people.map(p => [p.id, {...p}]));

    // Инициализируем поле children у каждого человека
    people.forEach(p => {
      p.children = [];
    });

    // Заполняем детей у родителей
    people.forEach(p => {
      if(p.parents?.length === 2){
        const father = map.get(p.parents[0]);
        const mother = map.get(p.parents[1]);
        if(father) father.children.push(p.id);
        if(mother) mother.children.push(p.id);
      }
    });

    // Ищем корней (у кого нет родителей)
    const roots = people.filter(p => !p.parents || p.parents.length === 0);

    if(roots.length > 1){
      const virtualRoot = {
        id: "root",
        name: "Общий корень",
        surname: "",
        patronymic: "",
        gender: "male",
        spouses: [],
        parents: [],
        children: roots.map(r => r.id)
      };
      map.set(virtualRoot.id, virtualRoot);
      return buildHierarchy(virtualRoot.id, map);
    } else if(roots.length === 1) {
      return buildHierarchy(roots[0].id, map);
    } else {
      throw new Error("Не найден корень дерева — проверьте данные!");
    }
  }

  function buildHierarchy(id, map, processed = new Set()) {
    if(processed.has(id)) return { id, isReference: true };
    processed.add(id);

    const person = map.get(id);
    if(!person) return null;

    // Находим первого супруга, кроме самого себя
    let spouseId = person.spouses && person.spouses.length > 0 ? person.spouses.find(sid => sid !== id) : null;

    let spouses = [person];
    if(spouseId){
      const spousePerson = map.get(spouseId);
      if(spousePerson) spouses.push(spousePerson);
    }

    let childrenIds = new Set();
    spouses.forEach(sp => {
      (sp.children || []).forEach(cid => childrenIds.add(cid));
    });

    const children = Array.from(childrenIds)
      .map(cid => buildHierarchy(cid, map, processed))
      .filter(c => c !== null);

    return {
      id,
      spouses,
      children,
      isReference: false
    };
  }

  function toggle(d) {
    if(d.children){
      d._children = d.children;
      d.children = null;
    } else if(d._children){
      d.children = d._children;
      d._children = null;
    }
  }

  function render(rootData) {
    const svg = d3.select("svg");
    svg.selectAll("*").remove();
    const width = +svg.attr("width");
    const height = +svg.attr("height");
    const g = svg.append("g").attr("transform", "translate(100,50)");

    // Сохраняем или инициализируем трансформ камеры
    let transform = svg.property("__currentTransform") || d3.zoomIdentity;

    const zoom = d3.zoom()
      .scaleExtent([0.5, 3])
      .on("zoom", event => {
        g.attr("transform", event.transform);
        svg.property("__currentTransform", event.transform);
      });
    svg.call(zoom).call(zoom.transform, transform);

    const dx = 300, dy = 280, spouseSpacing = 120, circleRadius = 28;

    const root = d3.hierarchy(rootData, d => d.children);

    d3.tree().nodeSize([dx, dy])(root);

    g.selectAll(".link")
      .data(root.links())
      .join("path")
      .attr("class", d => d.target.data.isReference ? "link link-dashed" : "link")
      .attr("d", d3.linkVertical()
        .x(d => d.x)
        .y(d => d.y));

    const nodes = g.selectAll(".node")
      .data(root.descendants(), d => d.data.id)
      .join(enter => enter.append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x},${d.y})`)
        .style("cursor", "pointer")
        .on("click", (_, d) => {
          toggle(d.data);
          render(rootData);
        })
      );

    nodes.each(function(d) {
      const el = d3.select(this);
      const sp = d.data.spouses;
      if(!sp) return;

      const surnameDisplay = p => {
        if (p.gender === "female" && p.spouses?.length && p.maidenSurname && p.maidenSurname !== p.surname)
          return p.surname;
        return p.surname;
      };

      const addMaiden = (p, x) => {
        if (p.gender === "female" && p.spouses?.length && p.maidenSurname && p.maidenSurname !== p.surname) {
          el.append("text")
            .attr("class", "maiden")
            .attr("x", x)
            .attr("y", circleRadius + 16)
            .attr("text-anchor", "middle")
            .text(`(дев. ${p.maidenSurname})`);
        }
      };

      if (sp.length === 2) {
        const [a, b] = sp;
        el.append("circle").attr("class", a.gender === "male" ? "male" : "female").attr("r", circleRadius).attr("cx", -spouseSpacing / 2);
        el.append("circle").attr("class", b.gender === "male" ? "male" : "female").attr("r", circleRadius).attr("cx", spouseSpacing / 2);
        el.append("text").attr("class", "surname").attr("y", -circleRadius - 14).attr("x", -spouseSpacing / 2).attr("text-anchor", "middle").text(surnameDisplay(a));
        el.append("text").attr("class", "surname").attr("y", -circleRadius - 14).attr("x", spouseSpacing / 2).attr("text-anchor", "middle").text(surnameDisplay(b));
        addMaiden(a, -spouseSpacing / 2);
        addMaiden(b, spouseSpacing / 2);
        el.append("text").attr("x", -spouseSpacing / 2).attr("y", circleRadius + 36).attr("text-anchor", "middle").text(a.name);
        if (a.patronymic) el.append("text").attr("x", -spouseSpacing / 2).attr("y", circleRadius + 52).attr("text-anchor", "middle").text(a.patronymic);
        el.append("text").attr("x", spouseSpacing / 2).attr("y", circleRadius + 36).attr("text-anchor", "middle").text(b.name);
        if (b.patronymic) el.append("text").attr("x", spouseSpacing / 2).attr("y", circleRadius + 52).attr("text-anchor", "middle").text(b.patronymic);
      } else {
        const a = sp[0];
        el.append("circle").attr("class", a.gender === "male" ? "male" : "female").attr("r", circleRadius);
        el.append("text").attr("class", "surname").attr("y", -circleRadius - 14).attr("text-anchor", "middle").text(surnameDisplay(a));
        addMaiden(a, 0);
        el.append("text").attr("x", 0).attr("y", circleRadius + 36).attr("text-anchor", "middle").text(a.name);
        if (a.patronymic) el.append("text").attr("x", 0).attr("y", circleRadius + 52).attr("text-anchor", "middle").text(a.patronymic);
      }

      if (d.data.isReference) {
        el.append("text").attr("y", circleRadius + 48).attr("text-anchor", "middle").attr("fill", "#888").attr("font-style", "italic").text("(уже отображено)");
      }
    });
  }
</script>
</body>
</html>
