<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Два дерева супругов</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; overflow: hidden; }
    .link { fill: none; stroke: #999; stroke-width: 2px; }
    .link-dashed { stroke-dasharray: 4 2; stroke: #bbb; }
    .spouse-link { stroke: #555; stroke-width: 3px; stroke-opacity: 0.6; }
    .node circle { stroke: #555; stroke-width: 2px; cursor: pointer; }
    .male { fill: #5dade2; }
    .female { fill: #f1948a; }
    text { font-size: 12px; user-select: none; pointer-events: none; }
    .surname { font-weight: bold; }
    .maiden { font-style: italic; font-size: 11px; fill: #666; }
  </style>
</head>
<body>
  <svg width="1800" height="1000"></svg>

  <script>
  let currentTransform = null;

  fetch("db.json")
    .then(r => r.json())
    .then(data => {
      const personMap = new Map(data.people.map(p => [p.id, p]));

      // Построение всех корней (пары без родителей)
      function buildRoots(people) {
        const pairsMap = new Map();

        people.forEach(p => {
          (p.spouses?.length ? p.spouses : [p.id]).forEach(spId => {
            const key = [p.id, spId].sort().join("_");
            if (!pairsMap.has(key)) pairsMap.set(key, { spouses: [p.id, spId].filter((v,i,a)=>a.indexOf(v)==i), children: [] });
          });
        });

        people.forEach(p => {
          if (p.parents?.length) {
            const key = [...p.parents].sort().join("_");
            const entry = pairsMap.get(key);
            if (!entry) pairsMap.set(key, { spouses: [...p.parents], children: [p.id] });
            else entry.children.push(p.id);
          }
        });

        const hasParents = id => personMap.get(id)?.parents?.length > 0;
        const roots = [];
        pairsMap.forEach((pair, key) => {
          if (pair.spouses.some(id => !hasParents(id))) {
            roots.push({ key, spouses: pair.spouses, children: pair.children, isReference: false });
          }
        });

        return roots;
      }

      // Построение рекурсивного дерева от пары
      function buildTree(rootPair, used = new Set()) {
        if (!rootPair) return null;
        if (used.has(rootPair.key)) return { ...rootPair, isReference: true, children: null };
        used.add(rootPair.key);

        const children = (rootPair.children || []).map(cid => {
          const p = personMap.get(cid);
          const childKey = [...new Set([p.id, ...(p.spouses || [])])].sort().join("_");
          return buildTree(allRoots.find(r => r.key === childKey), used);
        }).filter(n => n);

        return { ...rootPair, children };
      }

      // Фильтрация дерева для жены — чтобы не включать уже использованных
      function filterTree(tree, usedKeys = new Set()) {
        if (!tree) return null;
        if (usedKeys.has(tree.key)) return null;
        usedKeys.add(tree.key);
        const children = (tree.children || []).map(c => filterTree(c, usedKeys)).filter(n => n);
        return { ...tree, children };
      }

      const allRoots = buildRoots(data.people);
      const husbandPair = allRoots.find(r => r.spouses.some(id => personMap.get(id).gender === "male" && !personMap.get(id).parents.length));
      const wifePair = allRoots.find(r => r !== husbandPair && r.spouses.some(id => personMap.get(id).gender === "female" && !personMap.get(id).parents.length));

      const husbandTree = buildTree(husbandPair);
      const usedKeys = new Set();
      function markUsed(t) { if (!t) return; usedKeys.add(t.key); (t.children||[]).forEach(markUsed); }
      markUsed(husbandTree);
      const wifeTree = filterTree(buildTree(wifePair), usedKeys);

      render(husbandTree, wifeTree);

      function toggle(d) {
        if (d.children) { d._children = d.children; d.children = null; }
        else if (d._children) { d.children = d._children; d._children = null; }
        render(husbandTree, wifeTree);
      }

      function render(treeH, treeW) {
        const svg = d3.select("svg");
        svg.selectAll("*").remove();
        const g = svg.append("g").attr("transform", currentTransform || "translate(100,50)");
        svg.call(d3.zoom().scaleExtent([0.5,3]).on("zoom", e => {
          g.attr("transform", e.transform);
          currentTransform = e.transform;
        }));

        const dx = 300, dy = 300, spouseSpacing = 120, circleRadius = 28;
        const offsH = 0, offsW = 900;

        const rootH = d3.hierarchy(treeH, d => d.children);
        d3.tree().nodeSize([dx,dy])(rootH);
        const rootW = treeW ? d3.hierarchy(treeW, d => d.children) : null;
        if (rootW) d3.tree().nodeSize([dx,dy])(rootW);

        function drawLinks(root, offs) {
          if (!root) return;
          g.selectAll(".link"+offs)
           .data(root.links()).join("path")
           .attr("class", d => d.target.data.isReference ? "link link-dashed" : "link")
           .attr("d", d3.linkVertical().x(d=>d.x+offs).y(d=>d.y));
        }

        drawLinks(rootH, offsH);
        drawLinks(rootW, offsW);

        function drawNodes(root, offs) {
          if (!root) return;
          const sel = g.selectAll(".node"+offs)
           .data(root.descendants(), d=>d.data.key)
           .join(ent => ent.append("g")
             .attr("class","node")
             .attr("transform", d=>`translate(${d.x+offs},${d.y})`)
             .on("click", (_,d)=>{toggle(d.data);} ));

          sel.each(function(d){
            const el = d3.select(this), sp = d.data.spouses;
            const surnameDisplay = p => p.surname;
            const addMaiden = (p,x) => { if (p.gender==="female" && p.maidenSurname && p.maidenSurname!==p.surname) {
              el.append("text").attr("class","maiden").attr("x",x).attr("y",circleRadius+16).attr("text-anchor","middle")
                .text(`(дев. ${p.maidenSurname})`);
            }};
            if (sp.length===2) {
              const [a,b] = sp.map(id=>personMap.get(id));
              el.append("circle").attr("class",a.gender==="male"?"male":"female").attr("r",circleRadius).attr("cx",-spouseSpacing/2);
              el.append("circle").attr("class",b.gender==="male"?"male":"female").attr("r",circleRadius).attr("cx",spouseSpacing/2);
              el.append("text").attr("class","surname").attr("y",-circleRadius-14).attr("x",-spouseSpacing/2).attr("text-anchor","middle").text(surnameDisplay(a));
              el.append("text").attr("class","surname").attr("y",-circleRadius-14).attr("x",spouseSpacing/2).attr("text-anchor","middle").text(surnameDisplay(b));
              addMaiden(a, -spouseSpacing/2); addMaiden(b, spouseSpacing/2);
              [a,b].forEach((p,i)=>{
                const x0 = i===0 ? -spouseSpacing/2 : spouseSpacing/2;
                el.append("text").attr("x",x0).attr("y",circleRadius+36).attr("text-anchor","middle").text(p.name);
                if (p.patronymic) el.append("text").attr("x",x0).attr("y",circleRadius+52).attr("text-anchor","middle").text(p.patronymic);
              });
            } else {
              const a = personMap.get(sp[0]);
              el.append("circle").attr("class",a.gender==="male"?"male":"female").attr("r",circleRadius);
              el.append("text").attr("class","surname").attr("y",-circleRadius-14).attr("text-anchor","middle").text(surnameDisplay(a));
              addMaiden(a,0);
              el.append("text").attr("x",0).attr("y",circleRadius+36).attr("text-anchor","middle").text(a.name);
              if (a.patronymic) el.append("text").attr("x",0).attr("y",circleRadius+52).attr("text-anchor","middle").text(a.patronymic);
            }
          });
        }

        drawNodes(rootH, offsH);
        drawNodes(rootW, offsW);

        // рисуем линии супругов между деревьями
        const mapH = new Map(); rootH.descendants().forEach(d=>d.data.spouses.forEach(id=>mapH.set(id,d)));
        if (rootW) {
          const mapW = new Map(); rootW.descendants().forEach(d=>d.data.spouses.forEach(id=>mapW.set(id,d)));
          for (const [id, dH] of mapH.entries()) {
            const dW = mapW.get(id);
            if (dW) {
              g.append("line").attr("class","spouse-link")
                .attr("x1", dH.x + offsH).attr("y1", dH.y)
                .attr("x2", dW.x + offsW).attr("y2", dW.y);
            }
          }
        }
      }

    })
    .catch(console.error);
  </script>
</body>
</html>
