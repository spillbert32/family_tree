<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Родовое древо</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
    }
    .node circle {
      stroke: steelblue;
      stroke-width: 3px;
    }
    .node text.name {
      font: 16px sans-serif;
      font-weight: bold;
      fill: #222;
    }
    .node text.dates {
      font: 13px sans-serif;
      fill: #666;
    }
    .link {
      fill: none;
      stroke: #999;
      stroke-width: 2px;
    }
  </style>
</head>
<body>

<h2>Родовое древо семьи</h2>
<svg width="1500" height="1000"></svg>

<script>
  const svg = d3.select("svg")
    .append("g")
    .attr("transform", "translate(100, 50)");

  const treeLayout = d3.tree().size([900, 1300]); // height, width

  function genderColor(gender) {
    if (gender === "male") return "#1f77b4";
    if (gender === "female") return "#e377c2";
    return "#ccc";
  }

  fetch('db.json')
    .then(response => response.json())
    .then(familyTreeData => {
      const personMap = new Map(familyTreeData.people.map(p => [p.id, p]));

      // Найдём корней (тех, у кого нет родителей)
      const roots = familyTreeData.people.filter(p => !p.parents || p.parents.length === 0);
      if (roots.length === 0) {
        console.error("Не найдено корневых предков");
        return;
      }

      // Рекурсивно строим древо
      function buildHierarchy(person) {
        const node = { ...person, children: [] };
        const children = familyTreeData.people.filter(p => p.parents?.includes(person.id));
        node.children = children.map(child => buildHierarchy(child));
        return node;
      }

      // Если много корней — создадим фиктивный корень
      let treeRoot;
      if (roots.length > 1) {
        treeRoot = {
          id: "virtual-root",
          name: "Общий предок",
          surname: "",
          gender: "",
          birthYear: "",
          children: roots.map(root => buildHierarchy(root))
        };
      } else {
        treeRoot = buildHierarchy(roots[0]);
      }

      const hierarchyData = d3.hierarchy(treeRoot);
      treeLayout(hierarchyData);

      svg.selectAll('.link')
        .data(hierarchyData.links())
        .join('path')
        .attr('class', 'link')
        .attr('d', d3.linkHorizontal()
          .x(d => d.y)
          .y(d => d.x));

      const node = svg.selectAll('.node')
        .data(hierarchyData.descendants())
        .join('g')
        .attr('class', 'node')
        .attr('transform', d => `translate(${d.y},${d.x})`);

      node.append('circle')
        .attr('r', 22)
        .attr('fill', d => genderColor(d.data.gender))
        .attr('stroke', 'steelblue')
        .attr('stroke-width', 3);

      node.append('text')
        .attr('class', 'name')
        .attr('dy', -12)
        .attr('x', d => d.children ? -30 : 30)
        .style('text-anchor', d => d.children ? 'end' : 'start')
        .text(d => `${d.data.name || ""} ${d.data.surname || ""}`);

      node.append('text')
        .attr('class', 'dates')
        .attr('dy', 12)
        .attr('x', d => d.children ? -30 : 30)
        .style('text-anchor', d => d.children ? 'end' : 'start')
        .text(d => {
          if (!d.data.birthYear) return "";
          return d.data.deathYear
            ? `${d.data.birthYear} - ${d.data.deathYear}`
            : `р. ${d.data.birthYear}`;
        });
    })
    .catch(err => console.error("Ошибка загрузки db.json:", err));
</script>

</body>
</html>
