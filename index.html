<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Родовое древо с двумя строками для имени и отчества</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      overflow: hidden;
      margin: 0;
      padding: 10px;
    }
    .link {
      fill: none;
      stroke: #999;
      stroke-width: 2px;
    }
    .link-dashed {
      stroke-dasharray: 4 2;
      stroke: #bbb;
    }
    .node circle {
      stroke: #555;
      stroke-width: 2px;
    }
    .male {
      fill: #5dade2;
    }
    .female {
      fill: #f1948a;
    }
    text {
      font-size: 12px;
      user-select: none;
    }
    .surname {
      font-weight: bold;
      font-size: 14px;
      dominant-baseline: hanging;
    }
    .maidenSurname {
      font-style: italic;
      font-size: 10px;
    }
  </style>
</head>
<body>
  <h1>Родовое древо</h1>
  <div id="tree"></div>

  <script>
    // Размеры и отступы
    const width = 1400;
    const height = 900;
    const circleRadius = 30;
    const verticalSpacing = 140;
    const horizontalSpacing = 160;
    const spouseSpacing = 80;

    // Данные семейного древа (пример)
    const data = {
      people: [
        {"id":"p1","name":"Пётр","surname":"Мариничев","patronymic":"","birthYear":1950,"gender":"male","spouses":["p2"],"parents":[]},
        {"id":"p2","name":"Галина","surname":"Рыбасова","patronymic":"Александровна","maidenSurname":"Смирнова","birthYear":1953,"gender":"female","spouses":["p1"],"parents":[]},
        {"id":"p3","name":"Александр","surname":"Мариничев","patronymic":"Петрович","birthYear":1975,"gender":"male","spouses":["p4"],"parents":["p1","p2"]},
        {"id":"p4","name":"Ольга","surname":"Иванова","patronymic":"Викторовна","maidenSurname":"Кузнецова","birthYear":1978,"gender":"female","spouses":["p3"],"parents":[]},
        {"id":"p5","name":"Олег","surname":"Мариничев","patronymic":"Петрович","birthYear":1978,"gender":"male","spouses":["p6"],"parents":["p1","p2"]},
        {"id":"p6","name":"Ирина","surname":"Шаповалова","patronymic":"Сергеевна","maidenSurname":"Лебедева","birthYear":1980,"gender":"female","spouses":["p5"],"parents":[]},
        {"id":"p7","name":"Дмитрий","surname":"Мариничев","patronymic":"Петрович","birthYear":1983,"gender":"male","spouses":["p8"],"parents":["p1","p2"]},
        {"id":"p8","name":"Палия","surname":"Соколова","patronymic":"Владимировна","maidenSurname":"Морозова","birthYear":1985,"gender":"female","spouses":["p7"],"parents":[]},
        {"id":"p9","name":"Владислав","surname":"Мариничев","patronymic":"Олегович","birthYear":2002,"gender":"male","spouses":[],"parents":["p5","p6"]},
        {"id":"p10","name":"Полина","surname":"Мариничева","patronymic":"Олеговна","birthYear":2006,"gender":"female","spouses":[],"parents":["p5","p6"]},
        {"id":"p11","name":"Арсений","surname":"Мариничев","patronymic":"Дмитриевич","birthYear":2008,"gender":"male","spouses":[],"parents":["p7","p8"]},
        {"id":"p12","name":"Виктория","surname":"Мариничева","patronymic":"Дмитриевна","birthYear":2010,"gender":"female","spouses":[],"parents":["p7","p8"]}
      ]
    };

    // Создаем карту людей по id
    const peopleById = {};
    data.people.forEach(p => { peopleById[p.id] = p; });

    // Добавляем поле children каждому человеку
    data.people.forEach(person => { person.children = []; });
    data.people.forEach(person => {
      person.parents.forEach(pid => {
        if (peopleById[pid]) {
          peopleById[pid].children.push(person.id);
        }
      });
    });

    // Находим корней (те, у кого нет родителей)
    const roots = data.people.filter(p => p.parents.length === 0);

    // Функция построения поддерева для человека по id
    function buildTree(id) {
      const person = peopleById[id];
      if (!person) return null;

      const spouses = person.spouses.filter(sid => peopleById[sid]);

      const node = {
        id: person.id,
        person,
        spouses: spouses.map(sid => peopleById[sid]),
        children: []
      };

      // Собираем детей, у которых этот человек или его супруг(а) - родители
      const childrenSet = new Set();

      [person.id, ...spouses.map(s => s.id)].forEach(parentId => {
        data.people.forEach(child => {
          if (child.parents.includes(parentId)) {
            childrenSet.add(child.id);
          }
        });
      });

      node.children = Array.from(childrenSet).map(cid => buildTree(cid));

      return node;
    }

    // Построение массива корневых деревьев (если их несколько)
    const treeData = roots.map(root => buildTree(root.id));

    // Создаем svg внутри div#tree
    const svg = d3.select("#tree")
      .append("svg")
      .attr("width", width)
      .attr("height", height)
      .style("border", "1px solid #ccc");

    const treeGroup = svg.append("g").attr("transform", "translate(60, 60)");

    const treeLayout = d3.tree().nodeSize([horizontalSpacing, verticalSpacing]);

    // Объединяем корни под фиктивным узлом
    const superRoot = { id: "superRoot", children: treeData };
    const rootHierarchy = d3.hierarchy(superRoot, d => d.children);

    // Вычисляем позиции
    treeLayout(rootHierarchy);

    // Сдвиг вниз, чтобы убрать фиктивный корень
    const offsetY = verticalSpacing;
    treeGroup.attr("transform", `translate(60, ${offsetY + 60})`);

    // Рисуем связи
    treeGroup.selectAll(".link")
      .data(rootHierarchy.links())
      .join("path")
      .attr("class", "link")
      .attr("d", d3.linkVertical()
        .x(d => d.x)
        .y(d => d.y));

    // Рисуем узлы
    const node = treeGroup.selectAll(".node")
      .data(rootHierarchy.descendants().filter(d => d.data.id !== "superRoot"))
      .join("g")
      .attr("class", "node")
      .attr("transform", d => `translate(${d.x},${d.y})`);

    // Функция вывода фамилии (можно расширить при необходимости)
    function surnameDisplay(p) {
      return p.surname;
    }

    node.each(function(d) {
      const el = d3.select(this);
      const sp = d.data.spouses || [];
      const person = d.data.person;

      if (sp.length === 2) {
        const [a, b] = sp;

        // Кружочки супругов
        el.append("circle")
          .attr("class", a.gender === "male" ? "male" : "female")
          .attr("r", circleRadius)
          .attr("cx", -spouseSpacing / 2);
        el.append("circle")
          .attr("class", b.gender === "male" ? "male" : "female")
          .attr("r", circleRadius)
          .attr("cx", spouseSpacing / 2);

        // Текст для а
        el.append("text")
          .attr("class", "surname")
          .attr("x", -spouseSpacing / 2)
          .attr("y", -10)
          .attr("text-anchor", "middle")
          .text(a.name);
        if (a.patronymic) {
          el.append("text")
            .attr("x", -spouseSpacing / 2)
            .attr("y", 6)
            .attr("text-anchor", "middle")
            .text(a.patronymic);
        }

        // Текст для b
        el.append("text")
          .attr("class", "surname")
          .attr("x", spouseSpacing / 2)
          .attr("y", -10)
          .attr("text-anchor", "middle")
          .text(b.name);
        if (b.patronymic) {
          el.append("text")
            .attr("x", spouseSpacing / 2)
            .attr("y", 6)
            .attr("text-anchor", "middle")
            .text(b.patronymic);
        }
      } else {
        // Один человек (или нет супругов)
        const p = person || d.data;

        el.append("circle")
          .attr("class", p.gender === "male" ? "male" : "female")
          .attr("r", circleRadius);

        el.append("text")
          .attr("class", "surname")
          .attr("y", -10)
          .attr("text-anchor", "middle")
          .text(p.name);

        if (p.patronymic) {
          el.append("text")
            .attr("y", 6)
            .attr("text-anchor", "middle")
            .text(p.patronymic);
        }
      }
    });
  </script>
</body>
</html>
